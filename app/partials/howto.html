<div ng-controller="ModelCtrl">

<section id="intro">
    <h1>Welcome to forms-angular</h1>

    <div class="row-fluid">
        <div class="hero-unit span6 big-box">
            <h4>Turn this...</h4>
    <pre>var PersonSchema = new Schema({
    surname: {type:String, required:true, index:true},
    forename: {type:String, index:true},
    weight: Number,
    eyeColour: {type: String, required:true,
        enum:['Blue','Brown','Green','Hazel']},
    dateOfBirth: Date,
    accepted: Boolean
});</pre>
        </div>
        <div class="hero-unit span6 big-box">
            <h4>...into this</h4>
            <img src="/img/screen.png" alt="Screen shot of simple form">
        </div>
    </div>
    <div class="row-fluid">
        <div class="span8 offset2">
            <h4 class="text-center">...with three lines of code!</h4>

            <p class="text-center">(though you will find it easier to start with the <a
                    href="https://github.com/mchapman/forms-angular/tree/master/minimal" target="_blank">sample
                example</a> or follow the <a href="/#/build-app">build an app instructions</a> to understand how they fit in)</p>
    <pre>
var DataFormHandler = new (require('data_form.js'))(app)
DataFormHandler.addResource('Person',require('person_schema.js'))

&ltform-input schema="formSchema"&gt&lt/form-input&gt</pre>
        </div>
    </div>
    <br/>

    <p><strong>forms-angular</strong> is a form builder build on top of the <a
            href="http://blog.mongodb.org/post/49262866911/the-mean-stack-mongodb-expressjs-angularjs-and">MEAN
        stack</a>
        (with a little <a href="http://twitter.github.io/bootstrap/">Twitter Bootstrap</a> and <a
                href="http://mongoosejs.com/">Mongoose</a> thrown in for good measure) that
        enables you to generate forms super quickly. At its simplest it takes a mongoose schema and <em>with no effort
            on your part</em> generates a form, complete with REST routing and bindings.</p>
</section>

<section id="forms"><h3>Forms</h3>

    <p>All the input forms in the demo application use a very simple one line view (the third line of code above)
        which generates the forms on the client using the Mongoose schemas, optionally fine-tuned by hand.</p>

    <p>This demo application uses the models in the table below. Have a look at a schema or two and then click on the
        new
        link to see the forms that are generated by them.
    </p>
    <table class="table table-striped table-condensed">
        <tr ng-repeat="model in models | orderBy:'resource_name'">
            <td>{{model.resource_name | titleCase}}</td>
            <td><a href="/code/{{model.resource_name}}.js">View schema</a></td>
            <td><a href="/#/{{model.resource_name}}/new">New</a></td>
            <td><a href="/#/{{model.resource_name}}">List</a></td>
        </tr>
    </table>
    <p>For those who want to see the gory detail the
        <a href="/js/directives/form.js">forms</a> and the <a href="/js/directives/form-buttons.js">buttons</a> are
        generated by directives and the schema processing / behaviour is handled by a <a href="/js/controllers/base.js">controller</a>.
        The library currently weighs in at 17.3Kb minimised (obviously the ui dependencies and angular itself add
        substantially to that).</p>

    <p>For each model the following routes are supported:</p>

    <ul>
        <li><strong>/#/:model</strong> which lists the documents in the collection, with links to the form for editing
            them
        </li>
        <li><strong>/#/:model/new</strong> which enables the user to create a new document using the default form for
            the collection
        </li>
        <li><strong>/#/:model/:id/edit</strong> which enables the user to edit a document</li>
    </ul>
</section>

<section id="custom-form-schemas"><h3>Custom Form Schemas</h3>

    <p>It is easy to create custom form schemas which are a subset of the whole schema by specifying the fields
        to include and any options. See the static in <a href="/code/b_using_options.js">this example</a>.
        The custom form schemas are invoked as follows:
    </p>
    <ul>
        <li><strong>/#/:model/:formschema</strong> (<a href="/#/b_using_options/justnameandpostcode/">example here</a>)
        </li>
        <li><strong>/#/:model/:formschema/new</strong> (<a href="/#/b_using_options/justnameandpostcode/new">example
            here</a>)
        </li>
        <li><strong>/#/:model/:formschema/:id/edit</strong></li>
    </ul>

    <p>You can also create form schemas by hand (or dynamically in code), rather than using the ones that are generated from a Mongoose schema.
        This allows the use of <strong>containers</strong>.  For example:</p>
    <pre>
&ltform-input ng-init="names=[
  {containerType:'fieldset',title:'Name',content:
    [
      {id:'f_surname',label:'Surname',name:'surname',type:'text'},
      {id:'f_forename',label:'forename',name:'forename',type:'text'}
    ]
  }
]" schema="names"&gt&lt/form-input&gt</pre>
    <p>Other containers are <strong>tab</strong>, <strong>pane</strong> (which sets up a tab set if necessary),
        <strong>well</strong>, <strong>well-large</strong> and <strong>well-small</strong>.</p>

    <p>If you want to &quot;roll your own&quot; you can do something like:</p>
    <pre>
&ltstyle&gt
  .redBorder {border:solid 2px red;}
  p.bigRed {color: red; font-size: large}
&lt/style&gt
&ltform-input ng-init="names=[
  {containerType:'redBorder',title:'Name',titleTagOrClass:'bigRed',content:
    [
      {id:'f_surname',label:'Surname',name:'surname',type:'text'},
      {id:'f_forename',label:'forename',name:'forename',type:'text'}
    ]
  }
]" schema="names"&gt&lt/form-input&gt
</pre>
    <p>Where container type is seen as a class for a div and a titleTagOrClass of h1..h6 is interpreted as a heading tag and anything as a class to be applied to a paragraph (as in the example).</p>
</section>

<section id="schema-options" ><h3>Schema Options</h3>

    <p>The mark-up of generated forms can be influenced by use of the <strong>form</strong> object in the schema type.
        The form object can have the following keys:</p>
    <ul>
        <li><strong>hidden</strong> inhibits this schema key from appearing on the generated form.</li>
        <li><strong>label</strong> overrides the default input label. label:null suppresses the label altogether.</li>
        <li><strong>placeHolder</strong> adds placeholder text to the input (depending on data type).</li>
        <li><strong>help</strong> adds help text under the input.</li>
        <li><strong>helpInline</strong> adds help to the right of the input.</li>
        <li><strong>size</strong> sets <a href="http://twitter.github.io/bootstrap/base-css.html#forms">control width</a>.
            Options are: mini, small, medium (default), large, xlarge, xxlarge and block-level..</li>
        <li><strong>directive</strong> allows you to specify custom behaviour.</li>
        <li><strong>readonly</strong> adds the readonly attribute to the generated input (doesn't work with date - and perhaps other types).</li>
        <li><strong>select2</strong> in an enum field or a reference field tells the system to use the
            <a href="http://ivaynberg.github.io/select2/"><em>select2</em></a> control rather than a
            <em>select</em>. If the number of options is large in a reference field then
            <strong>select2:{fngAjax:true}</strong> instructs the program to use ajax calls to query
            the server rather than downloading the table. The values in the select[2] control come
            from the <a href="/#/index#listing">listing fields</a>.</li>
        <li><strong>rows</strong> sets the number of rows in inputs (such as textarea) that support this.  Setting rows to
            <strong>"auto"</strong> makes the textarea expand to fit the content, rather than create a scrollbar.
        <li><strong>pane</strong> used to divide a large form up into panes accessed by tabs
            (see <a href="/#/i_tabbed_forms/new">example</a>). This requires using the UI Bootstrap tabs module which
            is not in the minimal deployment folder (but is in this demo).</li>
        <li><strong>noAdd</strong> inhibits an Add button being generated for arrays.</li>
        <li><strong>noRemove</strong> inhibits a Remove button being generated for array elements.</li>
        <li><strong>add</strong> allows arbitrary attributes to be added to the input tag.  Useful for adding classes.</li>
        <li><strong>link</strong> sets up hyperlinks for reference fields as follows:
        <ul>
            <li><em>linkOnly</em> if true (which at the time of writing is the only option supported) then the input element is not generated.</li>
            <li><em>text</em> the text used for the link.</li>
        </ul>
    </ul>

    <p><a href="/code/b_using_options.js">This example schema</a> and <a href="/#/b_using_options/new">this form</a> show
    many of these options in use.</p>
</section>

<section id="listing">
    <h3>Listing</h3>

    <p>The listing routes (of the format <strong>/#/:model</strong>) are used to build a page
        containing a list of documents in the collection, showing the fields that have a truthy <strong>list</strong>
        key. If none of the schema objects have a list key the first two string fields are used.
    </p>

    <p>Listing routes support filters, such as</p>

    <a href="/#/b_using_options?f=%7B%22surname%22:%22Smith%22%7D">
        <pre>/#/b_using_options?f={"surname":"Smith"}</pre>
    </a>

    <p>and calls to the aggregation framework, provided they project to an array of docs that contains an _id property
        which is used
        to select from the model. For example the (rather unpalatable)</p>
    <a href="/#/f_nested_schema?a=%5B%7B%22%24unwind%22%3A%22%24exams%22%7D%2C%7B%22%24sort%22%3A%7B%22exams.score%22%3A1%7D%7D%2C%7B%22%24group%22%3A%7B%22_id%22%3A%7B%22id%22%3A%22%24_id%22%7D%2C%22bestSubject%22%3A%7B%22%24last%22%3A%22%24exams.subject%22%7D%7D%7D%2C%7B%22%24match%22%3A%7B%22bestSubject%22%3A%22English%22%7D%7D%2C%7B%22%24project%22%3A%7B%22_id%22%3A%22%24_id.id%22%7D%7D%5D">
        <pre>/#/f_nested_schema?a=[{"$unwind":"$exams"},{"$sort":{"exams.score":1}},{"$group":{"_id":{"id":"$_id"},"bestSubject":{"$last":"$exams.subject"}}},{"$match":{"bestSubject":"English"}},{"$project":{"_id":"$_id.id"}}]</pre>
    </a>

    <p>selects all students who did better in their English exam than any other subject. To find out how to use the
        aggregation framework refer to the <a href="http://docs.mongodb.org/manual/core/aggregation/">MongoDB docs</a>.
    </p>

    <p>These can be combined (though there appears to be a problem unless the filter precedes the aggregation).</p>

    <p>By default the list order is the MongoDB natural order. The default list order for a table can be set by
        specifying a <strong>listOrder</strong> option in the model definition (see <a
                href="/code/g_conditional_fields.js">g_conditional_fields</a> for an example).</p>
</section>

<section id="api"><h3>API</h3>

    <p>The Angular controllers make use of the following API calls:</p>

    <ul>
        <li><strong>/api/models</strong> returns an array of all the models that are available to forms-angular</li>
        <li><strong>/api/schema/:model</strong> returns the schema for a model</li>
        <li><strong>/api/schema/:model/:customForm</strong> returns the schema for a model</li>
        <li><strong>/api/:model</strong> returns an array of all the documents in a model (needs pagination)</li>
        <li><strong>/api/:model/:id</strong> returns a single document from the collection</li>
        <li><strong>/api/:model/:id/list</strong> returns how a document should appear in a list</li>
    </ul>

    The calls that return data will strip out any fields that are defined as <strong>secure</strong> - for example
    <pre><code>passwordHash: {type: String, secure:true, form: {hidden: true}}</code></pre>
</section>

<section id="form-buttons">
    <h3>Form Buttons</h3>
    The form button customisation is currently limited to over-riding the default enabled state of the buttons by
    defining
    functions in a controller for the model (or model and form). See <a href="/demo/d-array-example.js">here</a> for an
    example.
</section>

<section id="search">
    <h3>Search</h3>

    <p>It is easy to incorporate a simple search form, as shown in the Navbar. When you enter text into it the
        SearchCtrl controller makes a call to the server which looks for matching data by searching the indexed
        fields in each model for values starting with the search string.
        There are other search API calls as shown below:</p>
    <ul>
        <li><strong>/api/search?q=string</strong> returns documents where the string is found at the beginning of an
            indexed field
        </li>
        <li><strong>/api/search/:model?q=string</strong> returns documents in the specified collection where the string
            is found at the beginning of an indexed field. Note that the search is case insensitive, so will be
            inefficient (and to be avoided on large datasets) until Mongo 2.5 comes out. (See issue <a
                    href="https://jira.mongodb.org/browse/SERVER-90" target="_blank">here</a>)
        </li>
        <li><strong>/api/search?q=string&f={<span><em>filterjson</em></span>}</strong> returns documents where the
            string is found at the beginning of an indexed field which satisfy the conditions in the filter.
        </li>
    </ul>
    <p>There are a number of options that can be added to model exports to modify the search behaviour. Examples can be
        found
        in the model definitions files for <a href="/code/f_nested_schema.js">f_nested_schema</a> and <a
                href="/code/g_conditional_fields.js">g_conditional_fields</a>.</p>
    <ul>
        <li><strong>searchImportance</strong> can be used to determine the order of table searches. There is an example
            in <a href="/code/g_conditional_fields.js">this</a> model.
        </li>
        <li><strong>searchOrder</strong> can be used to set the default ordering of the search results within a model.
            It is normally used in conjunction with searchImportance.
        </li>
        <li><strong>searchResultFormat</strong> allows fine control of the display of search results. It points to a
            function which returns an object which must contain the following:
            <ul>
                <li><strong>resource</strong> the model name (or model/customForm) that the search result will link to
                </li>
                <li><strong>resourceText</strong> the display name for the resource</li>
                <li><strong>id</strong> the id to link to</li>
                <li><strong>weighting</strong> specifies the sort ordering</li>
                <li><strong>text</strong> the display text for the item</li>
            </ul>
        </li>
    </ul>

    A truthy <strong>noSearch</strong> key means index on a schema type is not used in the searchBox searches.
    A use case for this would be an index that is used in reports for grouping which has no meaning in a search.
</section>

<section id="client-side-customisation"><h3>Client Side Customisation</h3>

    Additional functionality can be added by using "model controllers" which have the name of
    a model followed by <strong>Ctrl</strong> (or the name of the model followed by the name of
    the custom form followed by Ctrl.  There is an sample model controller <a href="/demo/b-using-options.js">here</a>
    which is used in the examples in this section. The NavCtrl controller handles the model controllers, so don't remove it.

    <h5 id="naming" name="naming">Naming</h5>
    The BaseCtrl scope has a variable called <strong>modelNameDisplay</strong> which is used in several places in the demo
    app.  It defaults to the model name in title case, but can be over-ridden in the model controller.

    <h5>Menu</h5>
    <p>The menu can be added to where required by the models (see an example <a href="/#/b_using_options">here</a>)
        The options can be configured to appear when records are being listed, edited or created.  The top level text is
        taken from the model controller's <strong>dropDownDisplay</strong> variable, if present.  If not present it will
        fall back to the modelNameDisplay (see above) and it that is not present the model name.</p>

    <h5 id="postprocessing">Post form-input generation processing</h5>
    <p>The form-input directive broadcasts a <strong>formInputDone</strong> message when it has
    processed a control.  This can be acted on by the model controller.  In our <a href="/#/b_using_options">example</a> we
    add a change handler to a select2 control which changes background color of a control group
    when the eye colour is changed.</p>

    <h5>Client side data events</h5>
    <p>There are hooks before and after CRUD events as follows:</p>
    <ul>
        <li>onBeforeCreate function(data, callback(err))</li>
        <li>onAfterCreate function(data)</li>
        <li>onBeforeRead function(id, callback(err))</li>
        <li>onAfterRead function(data)</li>
        <li>onBeforeUpdate function(data, old, callback(err))</li>
        <li>onAfterUpdate function(data, old)</li>
        <li>onBeforeDelete function(old, callback(err))</li>
        <li>onAfterDelete function(old)</li>
    </ul>
    <p>In all onBefore... cases passing an error back will stop the event completing.  There is a trivial example of
    how a data event hook might be used in <a href="/demo/d-array-example.js">this</a> controller.</p>

    <h5>Adding additional attributes to all elements.</h5>
    <p>It is possible to apply additional attributes to all elements of a certain type by passing it once in the form-input declaration. The available types are Control Group, Field or Label.</p>
    <p>This can be achieved in two ways. Either as an attribute of the form-input element: <pre>&lt;form-input schema="formSchema" <span>add-all-group="injected-element='with paramters'"</span>&gt;</pre> or via the controller by making it an attribute of scope: <pre><span>$scope.addAllGroup="injected-attribute"</span></pre></p>
    <p>The three versions of this are: 
        <ul>
            <li>add-all-group="injected-attrbute"</li>
            <li>add-all-field="injected-attrbute"</li>
            <li>add-all-label="injected-attrbute"</li>
        </ul>
        For example if wished to inject a directive called 'hide-on-empty' to every individial control group then you would add: <pre>add-all-group="hide-on-empty"</pre> to the form-input declaration.
    </p>
    <p>If declared in a controller then it will be applied to all child controllers. If declared in the form-input element the scope is limited to the individual form's scope. In this way a single declaration at the root scope is seem by all controllers.</p>
    <p>Due to the parse method, in order declare multiple classes each class must be prefixed with 'class=' e.g. <pre>&lt;form-input schema="formSchema" <span>add-all-group="injected-element='with paramters' class=myclass class=my-second-class"</span>&gt;</pre></p>

</section>

<section id="server-side-customisation"><h3>Server Side Customisation</h3>
    <h5>Server side data events</h5>
    <p>On the server side there are hooks around data events as follows:</p>
    <ul>
        <li>findFunc function(req, callback(err, query)) applies a filter to records returned by the server. A common use case is to restrict a user to only see their own records.</li>
        <li>onSave function(doc, req, callback(err)) is a pre save hook that allows access to the record and the environment.  A common use case is to apply 'fine-grain' authentication.</li>
    </ul>
    <p>There are examples of both in <a href="/code/b_using_options.js">this</a> model</p>
</section>

<section id="reports"><h3>Reports</h3>
    <p>Reports can be run by passing an <a href="http://docs.mongodb.org/manual/core/aggregation-pipeline/">aggregation pipeline</a>
    to the server using the format <strong>/#/analyse/model?r=[pipeline]</strong> - for example
    <a href="/#/analyse/g_conditional_fields?r=%5B%7B%22$group%22:%7B%22_id%22:%22$sex%22,%22count%22:%7B%22$sum%22:1%7D%7D%7D%5D">/#/analyse/g_conditional_fields?r=[{"$group":{"_id":"$sex","count":{"$sum":1}}}]</a>
    produces a breakdown of the men and women in a collection.</p>

    <h5>Options</h5>
        <p>Reports can be enhanced by passing an object containing the pipeline as a property, along with a number of
    options:</p>
    <ul>
        <li><strong>title</strong> this option allows a title to be specified.  The default is the model name.</li>
        <li><strong>columnDefs</strong> an array of column instruction objects which determines the output order and appearance.
            For full details see <a href="https://github.com/angular-ui/ng-grid/wiki/Defining-columns">the ng-grid documentation</a>
            but the most common uses are:
            <ul>
                <li><strong>field</strong> the name of the field in the model</li>
                <li><strong>displayName</strong> (optional) the column heading</li>
                <li><strong>width</strong> (optional) the desired display width</li>
                <li><strong>cellClass</strong> (optional) a CSS class to be added to the cell (<em>fngRight</em> is a useful one).</li>
                <li><strong>cellFilter</strong> (optional) an Angular filter (such as <em>number</em> or <em>currency</em> to be applied to the value.</li>
                <li><strong>totalsRow</strong> (optional - <strong>an extension to ng-grid</strong>) a text value (generally "Total") or <em>$SUM</em></li>
            </ul>
        <li><strong>columnTranslations</strong> an array of objects giving instructions for translating returned data.  The objects are made up as follows:
            <ul>
                <li><strong>field</strong> (mandatory) the name of the results column to translate</li>
                <li><strong>ref</strong> the name of a Mongoose model to use to look up the current value against (returning a concatenation of the fields with a truthy <strong>list</strong> key)</li>
                <li><strong>translations</strong> an array of value&rarr;display mappings, such as <strong>[{value:'M', display:'Male'},{value:'F', display:'Female'}]</strong></li>
            </ul>
        </li>
        <li><strong>params</strong> contains an array of parameters that can be used in the pipeline, normally in a $match such as {$match:{sex:("sex")}}.  Parameters can have the following properties:
            <ul>
                <li><strong>value</strong> is the (mandatory) value used for the query when the page is first generated</li>
                <li><strong>type</strong> can be <em>'text'</em> (default), <em>'number'</em> or <em>'select'</em>.  In the case of <em>'select'</em> values must be defined for</li>
                <li><strong>label</strong> allows you to override the default input label</li>
                <li><strong>enum</strong> an array of values to populate a select input</li>
                <li><strong>required</strong> should set to true if the query cannot be run without the parameter</li>
                <li><strong>noInput</strong> can be set to true to prevent the parameter being prompted for.  Normally used in conjunction with</li>
                <li><strong>conversionExpression</strong> an angular expression which generates and / or formats the parameter at runtime.
                    For example <pre>param + ' ' + record.surname | uppercase</pre> would concatenate the values fom the current parameter
                    and the surname parameter and convert them to uppercase.</li>
            </ul>
        </li>
    </ul>
    <p>Use of date parameters is quite tricky.  The following works:</p>
        <pre>
        reportSchema = {
            pipeline: [
                {$match:{birth:"(ageMatch)"}},
                {$group:{_id:'People',count:{$sum:1}}
            ],
            params: {
                ageGroup: {value:'All', type:'select', enum:['All','65 and over','Under 65'], required:true, size:'medium'},
                ageMatch: {value:{$gt:"1800-01-01T00:00:00.000Z"}, type:'text', noInput: true, conversionExpression: "record | ageMatch"}
                }
        };
        </pre>
    with this filter:
        <pre>
        myApp.filter('ageMatch',[function() {
            return function(record) {
                var thisYear = new Date().getYear();
                switch (record.ageGroup) {
                    case 'All' :
                        return '{"$gt":"1800-01-01T00:00:00.000Z"}';
                    case '65 and over':
                        return '{"$lt":"' + (thisYear - 64) + '-01-01T00:00:00.000Z"}';
                    case 'Under 65' :
                        return '{"$gte":"' + (thisYear - 64) + '-01-01T00:00:00.000Z"}';
                }
            }
        }]);
        </pre>

    <p>Using these options the report above can be <a href="/#/analyse/g_conditional_fields?r=%7B%22pipeline%22:%5B%7B%22$group%22:%7B%22_id%22:%22$sex%22,%22count%22:%7B%22$sum%22:1%7D%7D%7D%5D,%22title%22:%22Breakdown%20By%20Sex%22,%22columnDefs%22:%5B%7B%22field%22:%22_id%22,%22displayName%22:%22Sex%22%7D,%7B%22field%22:%22count%22,%22displayName%22:%22No%20of%20Applicants%22%7D%5D%7D">tidied up</a>.</p>

    <h5>Report Schemas</h5>
    <p>If you looked at the link to that last report you would have realised that using the URL to specify a report format
        quickly becomes unmanageable.  A neater alternative is to put the options into an object which is served up via a
        static in the model file - see <a href="/code/g_conditional_fields.js">here</a> for some examples.</p>
</section>

</div>
